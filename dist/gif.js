// Generated by CommonJS Everywhere 0.9.7
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  var process = function () {
      var cwd = '/';
      return {
        title: 'browser',
        version: 'v0.10.32',
        browser: true,
        env: {},
        argv: [],
        nextTick: global.setImmediate || function (fn) {
          setTimeout(fn, 0);
        },
        cwd: function () {
          return cwd;
        },
        chdir: function (dir) {
          cwd = dir;
        }
      };
    }();
  require.define('/gif.coffee', function (module, exports, __dirname, __filename) {
    var browser, defaults, EventEmitter, frameDefaults, GIF;
    EventEmitter = require('events', module).EventEmitter;
    browser = require('/browser.coffee', module);
    GIF = function (super$) {
      extends$(GIF, super$);
      defaults = {
        workerScript: 'gif.worker.js',
        workers: 2,
        repeat: 0,
        background: '#fff',
        quality: 10,
        width: null,
        height: null,
        transparent: null
      };
      frameDefaults = {
        delay: 500,
        copy: false
      };
      function GIF(options) {
        var key, value;
        this.running = false;
        this.options = {};
        this.frames = [];
        this.freeWorkers = [];
        this.activeWorkers = [];
        this.setOptions(options);
        for (key in defaults) {
          value = defaults[key];
          if (null != this.options[key])
            this.options[key];
          else
            this.options[key] = value;
        }
      }
      GIF.prototype.setOption = function (key, value) {
        this.options[key] = value;
        if (null != this._canvas && (key === 'width' || key === 'height'))
          return this._canvas[key] = value;
      };
      GIF.prototype.setOptions = function (options) {
        var key, value;
        return function (accum$) {
          for (key in options) {
            if (!isOwn$(options, key))
              continue;
            value = options[key];
            accum$.push(this.setOption(key, value));
          }
          return accum$;
        }.call(this, []);
      };
      GIF.prototype.addFrame = function (image, options) {
        var frame, key;
        if (null == options)
          options = {};
        frame = {};
        frame.transparent = this.options.transparent;
        for (key in frameDefaults) {
          frame[key] = options[key] || frameDefaults[key];
        }
        if (!(null != this.options.width))
          this.setOption('width', image.width);
        if (!(null != this.options.height))
          this.setOption('height', image.height);
        if ('undefined' !== typeof ImageData && null != ImageData && image instanceof ImageData) {
          frame.data = image.data;
        } else if ('undefined' !== typeof CanvasRenderingContext2D && null != CanvasRenderingContext2D && image instanceof CanvasRenderingContext2D || 'undefined' !== typeof WebGLRenderingContext && null != WebGLRenderingContext && image instanceof WebGLRenderingContext) {
          if (options.copy) {
            frame.data = this.getContextData(image);
          } else {
            frame.context = image;
          }
        } else if (null != image.childNodes) {
          if (options.copy) {
            frame.data = this.getImageData(image);
          } else {
            frame.image = image;
          }
        } else {
          throw new Error('Invalid image');
        }
        return this.frames.push(frame);
      };
      GIF.prototype.render = function () {
        var i, numWorkers;
        if (this.running)
          throw new Error('Already running');
        if (!(null != this.options.width) || !(null != this.options.height))
          throw new Error('Width and height must be set prior to rendering');
        this.running = true;
        this.nextFrame = 0;
        this.finishedFrames = 0;
        this.imageParts = function (accum$) {
          for (var cache$ = function () {
                var accum$1;
                accum$1 = [];
                for (var i$ = 0; 0 <= this.frames.length ? i$ < this.frames.length : i$ > this.frames.length; 0 <= this.frames.length ? ++i$ : --i$)
                  accum$1.push(i$);
                return accum$1;
              }.apply(this, arguments), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
            i = cache$[i$];
            accum$.push(null);
          }
          return accum$;
        }.call(this, []);
        numWorkers = this.spawnWorkers();
        if (this.options.globalPalette === true) {
          this.renderNextFrame();
        } else {
          for (var cache$1 = function () {
                var accum$1;
                accum$1 = [];
                for (var i$1 = 0; 0 <= numWorkers ? i$1 < numWorkers : i$1 > numWorkers; 0 <= numWorkers ? ++i$1 : --i$1)
                  accum$1.push(i$1);
                return accum$1;
              }.apply(this, arguments), i$1 = 0, length$1 = cache$1.length; i$1 < length$1; ++i$1) {
            i = cache$1[i$1];
            this.renderNextFrame();
          }
        }
        this.emit('start');
        return this.emit('progress', 0);
      };
      GIF.prototype.abort = function () {
        var worker;
        while (true) {
          worker = this.activeWorkers.shift();
          if (!(null != worker))
            break;
          console.log('killing active worker');
          worker.terminate();
        }
        this.running = false;
        return this.emit('abort');
      };
      GIF.prototype.spawnWorkers = function () {
        var numWorkers;
        numWorkers = Math.min(this.options.workers, this.frames.length);
        (function () {
          var accum$;
          accum$ = [];
          for (var i$ = this.freeWorkers.length; this.freeWorkers.length <= numWorkers ? i$ < numWorkers : i$ > numWorkers; this.freeWorkers.length <= numWorkers ? ++i$ : --i$)
            accum$.push(i$);
          return accum$;
        }.apply(this, arguments).forEach(function (this$) {
          return function (i) {
            var worker;
            console.log('spawning worker ' + i);
            worker = new Worker(this$.options.workerScript);
            worker.onmessage = function (this$1) {
              return function (event) {
                this$1.activeWorkers.splice(this$1.activeWorkers.indexOf(worker), 1);
                this$1.freeWorkers.push(worker);
                return this$1.frameFinished(event.data);
              };
            }(this$);
            return this$.freeWorkers.push(worker);
          };
        }(this)));
        return numWorkers;
      };
      GIF.prototype.frameFinished = function (frame) {
        var i;
        console.log('frame ' + frame.index + ' finished - ' + this.activeWorkers.length + ' active');
        this.finishedFrames++;
        this.emit('progress', this.finishedFrames / this.frames.length);
        this.imageParts[frame.index] = frame;
        if (this.options.globalPalette === true) {
          this.options.globalPalette = frame.globalPalette;
          console.log('global palette analyzed');
          if (this.frames.length > 2)
            for (var cache$ = function () {
                  var accum$;
                  accum$ = [];
                  for (var i$ = 1; 1 <= this.freeWorkers.length ? i$ < this.freeWorkers.length : i$ > this.freeWorkers.length; 1 <= this.freeWorkers.length ? ++i$ : --i$)
                    accum$.push(i$);
                  return accum$;
                }.apply(this, arguments), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
              i = cache$[i$];
              this.renderNextFrame();
            }
        }
        if (in$(null, this.imageParts)) {
          return this.renderNextFrame();
        } else {
          return this.finishRendering();
        }
      };
      GIF.prototype.finishRendering = function () {
        var data, frame, i, image, len, offset, page;
        len = 0;
        for (var i$ = 0, length$ = this.imageParts.length; i$ < length$; ++i$) {
          frame = this.imageParts[i$];
          len += (frame.data.length - 1) * frame.pageSize + frame.cursor;
        }
        len += frame.pageSize - frame.cursor;
        console.log('rendering finished - filesize ' + Math.round(len / 1e3) + 'kb');
        data = new Uint8Array(len);
        offset = 0;
        for (var i$1 = 0, length$1 = this.imageParts.length; i$1 < length$1; ++i$1) {
          frame = this.imageParts[i$1];
          for (var i$2 = 0, length$2 = frame.data.length; i$2 < length$2; ++i$2) {
            page = frame.data[i$2];
            i = i$2;
            data.set(page, offset);
            if (i === frame.data.length - 1) {
              offset += frame.cursor;
            } else {
              offset += frame.pageSize;
            }
          }
        }
        image = new Blob([data], { type: 'image/gif' });
        return this.emit('finished', image, data);
      };
      GIF.prototype.renderNextFrame = function () {
        var frame, task, worker;
        if (this.freeWorkers.length === 0)
          throw new Error('No free workers');
        if (this.nextFrame >= this.frames.length)
          return;
        frame = this.frames[this.nextFrame++];
        worker = this.freeWorkers.shift();
        task = this.getTask(frame);
        console.log('starting frame ' + (task.index + 1) + ' of ' + this.frames.length);
        this.activeWorkers.push(worker);
        return worker.postMessage(task);
      };
      GIF.prototype.getContextData = function (ctx) {
        return ctx.getImageData(0, 0, this.options.width, this.options.height).data;
      };
      GIF.prototype.getImageData = function (image) {
        var ctx;
        if (!(null != this._canvas)) {
          this._canvas = document.createElement('canvas');
          this._canvas.width = this.options.width;
          this._canvas.height = this.options.height;
        }
        ctx = this._canvas.getContext('2d');
        ctx.setFill = this.options.background;
        ctx.fillRect(0, 0, this.options.width, this.options.height);
        ctx.drawImage(image, 0, 0);
        return this.getContextData(ctx);
      };
      GIF.prototype.getTask = function (frame) {
        var index, task;
        index = this.frames.indexOf(frame);
        task = {
          index: index,
          last: index === this.frames.length - 1,
          delay: frame.delay,
          transparent: frame.transparent,
          width: this.options.width,
          height: this.options.height,
          quality: this.options.quality,
          dither: this.options.dither,
          globalPalette: this.options.globalPalette,
          repeat: this.options.repeat,
          canTransfer: browser.name === 'chrome'
        };
        if (null != frame.data) {
          task.data = frame.data;
        } else if (null != frame.context) {
          task.data = this.getContextData(frame.context);
        } else if (null != frame.image) {
          task.data = this.getImageData(frame.image);
        } else {
          throw new Error('Invalid frame');
        }
        return task;
      };
      return GIF;
    }(EventEmitter);
    module.exports = GIF;
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/browser.coffee', function (module, exports, __dirname, __filename) {
    var browser, mode, platform, ua, UA;
    ua = navigator.userAgent.toLowerCase();
    platform = navigator.platform.toLowerCase();
    UA = ua.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/) || [
      null,
      'unknown',
      0
    ];
    mode = UA[1] === 'ie' && document.documentMode;
    browser = {
      name: UA[1] === 'version' ? UA[3] : UA[1],
      version: mode || parseFloat(UA[1] === 'opera' && UA[4] ? UA[4] : UA[2]),
      platform: { name: ua.match(/ip(?:ad|od|hone)/) ? 'ios' : (ua.match(/(?:webos|android)/) || platform.match(/mac|win|linux/) || ['other'])[0] }
    };
    browser[browser.name] = true;
    browser[browser.name + parseInt(browser.version, 10)] = true;
    browser.platform[browser.platform.name] = true;
    module.exports = browser;
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('events', function (module, exports, __dirname, __filename) {
    if (!process.EventEmitter)
      process.EventEmitter = function () {
      };
    var EventEmitter = exports.EventEmitter = process.EventEmitter;
    var isArray = typeof Array.isArray === 'function' ? Array.isArray : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };
    var defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function (n) {
      if (!this._events)
        this._events = {};
      this._events.maxListeners = n;
    };
    EventEmitter.prototype.emit = function (type) {
      if (type === 'error') {
        if (!this._events || !this._events.error || isArray(this._events.error) && !this._events.error.length) {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
          return false;
        }
      }
      if (!this._events)
        return false;
      var handler = this._events[type];
      if (!handler)
        return false;
      if (typeof handler == 'function') {
        switch (arguments.length) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          var args = Array.prototype.slice.call(arguments, 1);
          handler.apply(this, args);
        }
        return true;
      } else if (isArray(handler)) {
        var args = Array.prototype.slice.call(arguments, 1);
        var listeners = handler.slice();
        for (var i = 0, l = listeners.length; i < l; i++) {
          listeners[i].apply(this, args);
        }
        return true;
      } else {
        return false;
      }
    };
    EventEmitter.prototype.addListener = function (type, listener) {
      if ('function' !== typeof listener) {
        throw new Error('addListener only takes instances of Function');
      }
      if (!this._events)
        this._events = {};
      this.emit('newListener', type, listener);
      if (!this._events[type]) {
        this._events[type] = listener;
      } else if (isArray(this._events[type])) {
        if (!this._events[type].warned) {
          var m;
          if (this._events.maxListeners !== undefined) {
            m = this._events.maxListeners;
          } else {
            m = defaultMaxListeners;
          }
          if (m && m > 0 && this._events[type].length > m) {
            this._events[type].warned = true;
            console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
            console.trace();
          }
        }
        this._events[type].push(listener);
      } else {
        this._events[type] = [
          this._events[type],
          listener
        ];
      }
      return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function (type, listener) {
      var self = this;
      self.on(type, function g() {
        self.removeListener(type, g);
        listener.apply(this, arguments);
      });
      return this;
    };
    EventEmitter.prototype.removeListener = function (type, listener) {
      if ('function' !== typeof listener) {
        throw new Error('removeListener only takes instances of Function');
      }
      if (!this._events || !this._events[type])
        return this;
      var list = this._events[type];
      if (isArray(list)) {
        var i = list.indexOf(listener);
        if (i < 0)
          return this;
        list.splice(i, 1);
        if (list.length == 0)
          delete this._events[type];
      } else if (this._events[type] === listener) {
        delete this._events[type];
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function (type) {
      if (type && this._events && this._events[type])
        this._events[type] = null;
      return this;
    };
    EventEmitter.prototype.listeners = function (type) {
      if (!this._events)
        this._events = {};
      if (!this._events[type])
        this._events[type] = [];
      if (!isArray(this._events[type])) {
        this._events[type] = [this._events[type]];
      }
      return this._events[type];
    };
  });
  global.GIF = require('/gif.coffee');
}.call(this, this));
// gif.js 0.1.6 - https://github.com/jnordberg/gif.js
